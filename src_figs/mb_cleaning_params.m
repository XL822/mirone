function varargout = mb_cleaning_params(varargin)
% Helper window to interface with the MB program 'mbaraeclean' and my own (naive) cleaning

%	Copyright (c) 2004-2018 by J. Luis
%
% 	This program is part of Mirone and is free software; you can redistribute
% 	it and/or modify it under the terms of the GNU Lesser General Public
% 	License as published by the Free Software Foundation; either
% 	version 2.1 of the License, or any later version.
% 
% 	This program is distributed in the hope that it will be useful,
% 	but WITHOUT ANY WARRANTY; without even the implied warranty of
% 	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
% 	Lesser General Public License for more details.
%
%	Contact info: w3.ualg.pt/~jluis/mirone
% --------------------------------------------------------------------

% $Id: mb_cleaning_params.m 10217 2018-01-24 21:33:46Z j $

	hObject = figure('Vis','off');
	mb_cleaning_params_LayoutFcn(hObject);
	handles = guihandles(hObject);
	move2side(hObject,'right');

	handles.areaclean = false;		% One of them will be set to TRUE
	handles.gridclean = false;

	if (nargin)
		BB = varargin{1};
		set(handles.edit_x_min,'String',sprintf('%.8g',BB(1)))
		set(handles.edit_x_max,'String',sprintf('%.8g',BB(2)))
		set(handles.edit_y_min,'String',sprintf('%.8g',BB(3)))
		set(handles.edit_y_max,'String',sprintf('%.8g',BB(4)))
		x_inc = 0.05 * BB(6) / 111000;		% Appriximate inc in degrees
		set(handles.edit_x_inc,'String',sprintf('%.10g',x_inc))
		set(handles.edit_y_inc,'String',sprintf('%.10g',x_inc))

		% These are needed in dim_funs()
		handles.x_min = BB(1);		handles.x_max = BB(2);
		handles.y_min = BB(3);		handles.y_max = BB(4);
		handles.x_min_or = BB(1);	handles.x_max_or = BB(2);
		handles.y_min_or = BB(3);	handles.y_max_or = BB(4);
		handles.x_inc = x_inc;		handles.y_inc = x_inc;
		handles.dms_xinc = 0;		handles.dms_yinc = 0;
		handles.one_or_zero = 1;
		guidata(hObject, handles);
		edit_x_inc_CB(handles.edit_x_inc, handles)		% Make it update the n_cols box
		edit_y_inc_CB(handles.edit_y_inc, handles)		% Make it update the n_rows box
	end

	%------------ Give a Pro look (3D) to the frame boxes  -------------------------------
	new_frame3D(hObject, [handles.text_gridclean handles.text_areaclean handles.text_STD ...
	                      handles.text_median handles.text_limits handles.text_opt_R])
	%------------- END Pro look (3D) -----------------------------------------------------
	set(hObject,'Visible','on');

	guidata(hObject, handles);

	if (nargout)
		% Make the GUI modal
		set(handles.figure1,'WindowStyle','modal')

		% UIWAIT makes yes_or_no wait for user response (see UIRESUME)
		uiwait(handles.figure1);
		if (~ishandle(hObject))			% Will not be if this Fig was already killed
			varargout{1} = '';
			return
		end
		handles = guidata(hObject);
		
		out.hFig = hObject;
		out.gridclean = handles.gridclean;
		out.areaclean =	handles.areaclean;

		if (handles.gridclean)
			out.grid_tol    = handles.grid_tol;
			out.grid_inc    = handles.grid_inc;
			out.grid_n_iter = handles.grid_n_iter;
		elseif (handles.areaclean)
			out.opt_D_active    = handles.opt_D_active;
			if (out.opt_D_active)
				out.opt_D_threshold = handles.opt_D_threshold;
				out.opt_D_nmin      = handles.opt_D_nmin;
			end
			out.opt_M_active    = handles.opt_M_active;
			if (out.opt_M_active)
				out.opt_M_threshold = handles.opt_M_threshold;
				out.opt_M_nmin      = handles.opt_M_nmin;
			end
			out.opt_N_active    = handles.opt_N_active;
			if (out.opt_N_active)
				out.opt_N_min       = handles.opt_N_min;
				out.opt_N_Rev       = handles.opt_N_Rev;
			end
			out.opt_R           = handles.opt_R;
			out.opt_S           = handles.opt_S;
			out.opt_G_active    = handles.opt_G_active;
		end
		varargout{1} = out;
		delete(handles.figure1);
	end

% ---------------------------------------------------------------------------------------------
function edit_percentDistGrid_CB(hObject, handles)
% ...

% ---------------------------------------------------------------------------------------------
function edit_nIterGrid_CB(hObject, handles)


% ---------------------------------------------------------------------------------------------
function edit_incGrid_CB(hObject, handles)


% ---------------------------------------------------------------------------------------------
function push_helpGrid_CB(hObject, handles)
% ...
	message = sprintf(['This method computes a grid internally and compares the distance of each beam ' ...
        'to that surface. Points that are further away than TOLERANCE times the water depth are ' ...
        'considered invalid.\n'
        'To achieve this goal we start with a tolerance that is N ITERATIONS higher and repeat the ' ...
        'procedure N ITERATIONS times till the final tolerance is reached. ' ...
        'The GRID SPACING is the grid increment used to calculate the internal grid. A value of ' ...
        'three times the typical point spacing is used. Enter a different value if not want to use that ' ...
		'default value.\n\n' ...
		'WARNING: this algorithm mat chop the tips of sharp edges, so use with care.']);
	helpdlg(message,'Help on Grid clean');

% ---------------------------------------------------------------------------------------------
function push_OKgrid_CB(hObject, handles)
% ...
	%Tolerance
	t = get(handles.edit_percentDistGrid, 'Str');
	ind = strfind(t, '%');		if (~isempty(ind)),		t(ind(1):end) = [];		end 	% Take care of the '%'
	tol = abs(str2double(t)) / 100;
	if (isnan(tol)),	set(handles.edit_percentDistGrid, 'Str', '1%'),		tol = 0.01;		end
	% N_ITER
	t = get(handles.edit_nIterGrid, 'Str');
	n_iter = abs(str2double(t));
	if (isnan(n_iter)),	set(handles.edit_nIterGrid, 'Str', '3'),	n_iter = 3;		end
	% Grid inc
	t = get(handles.edit_incGrid, 'Str');
	inc = abs(str2double(t));
	if (isnan(inc)),	set(handles.edit_incGrid, 'Str', ''),	inc = 0;	end
	handles.grid_tol = tol;		handles.grid_n_iter = n_iter;	handles.grid_inc = inc;

	handles.gridclean = true;
	guidata(handles.figure1, handles)

	uiresume(handles.figure1);

% ---------------------------------------------------------------------------------------------
function edit_x_min_CB(hObject, handles)
	dim_funs('xMin', hObject, handles)

% ---------------------------------------------------------------------------------------------
function edit_x_max_CB(hObject, handles)
	dim_funs('xMax', hObject, handles)

% ---------------------------------------------------------------------------------------------
function edit_y_min_CB(hObject, handles)
	dim_funs('yMin', hObject, handles)

% ---------------------------------------------------------------------------------------------
function edit_y_max_CB(hObject, handles)
	dim_funs('yMax', hObject, handles)

% ---------------------------------------------------------------------------------------------
function edit_x_inc_CB(hObject, handles)
	dim_funs('xInc', hObject, handles)

% ---------------------------------------------------------------------------------------------
function edit_y_inc_CB(hObject, handles)
	dim_funs('yInc', hObject, handles)

% ---------------------------------------------------------------------------------------------
function edit_Ncols_CB(hObject, handles)
	dim_funs('nCols', hObject, handles)

% ---------------------------------------------------------------------------------------------
function edit_Nrows_CB(hObject, handles)
	dim_funs('nRows', hObject, handles)

% ---------------------------------------------------------------------------------------------
function push_Help_R_F_T_CB(hObject, handles)
	message = sprintf(['Min and Max, of "X Direction" and "Y Direction" specify the Region of ' ...
        'interest.\n' ...
        '"Spacing" sets the bin size for volume statistics. X and Y spacings must be ' ...
        'equal or otherwise an average of the two is computed. ' ...
        'In "#of lines" it is offered the easyeast way of controling the grid ' ...
        'dimensions (lines & columns).']);
	helpdlg(message,'Help on Grid Geometry');

% ---------------------------------------------------------------------------------------------
function edit_opt_D_threshold_CB(hObject, handles)
% Just checks that use doesn't screw
	t = str2double(get(hObject, 'Str'));
	if (isnan(t) || t <= 0),		set(hObject, 'Str', '2'),	end

% ---------------------------------------------------------------------------------------------
function edit_opt_D_min_CB(hObject, handles)
% Just checks that use doesn't screw
	t = str2double(get(hObject, 'Str'));
	if (isnan(t) || t <= 0),		set(hObject, 'Str', '10'),	end

% ---------------------------------------------------------------------------------------------
function push_opt_D_help_CB(hObject, handles)
	message = sprintf(['Turns on use of a standard deviation filter test for the soundings.\n' ...
		'Soundings that differ from the mean depth by a value greater than threshold times the standard deviation ' ...
		'will be considered "bad".\n So, if threshold = 2.0, then any sounding that is twice the standard deviation ' ...
		'from the mean depth will be considered bad. The nmin parameter sets the minimum number of ' ...
		'soundings required to use the standard deviation filter.']);
	helpdlg(message,'Help on STD Filter');

% ---------------------------------------------------------------------------------------------
function edit_opt_M_threshold_CB(hObject, handles)
% Just checks that use doesn't screw
	t = str2double(get(hObject, 'Str'));
	if (isnan(t) || t <= 0),		set(hObject, 'Str', '0.1'),	end

% ---------------------------------------------------------------------------------------------
function edit_opt_M_min_CB(hObject, handles)
% Just checks that use doesn't screw
	t = str2double(get(hObject, 'Str'));
	if (isnan(t) || t <= 0),		set(hObject, 'Str', '10'),	end

% ---------------------------------------------------------------------------------------------
function push_opt_M_help_CB(hObject, handles)
	message = sprintf(['Turns on use of a median filter test for the soundings. Soundings that differ from the ' ...
		'median depth by a value greater than threshold times the sonar altitude will be considered "bad".\n\n' ...
		'So, if threshold = 0.05, then any sounding that is 5%% greater or less than the median depth will be ' ...
		'considered bad. The nmin parameter sets the minimum number of soundings required to use the median filter']);
	helpdlg(message,'Help on Median Filter');

% ---------------------------------------------------------------------------------------------
function edit_opt_N_min_CB(hObject, handles)
% Just checks that use doesn't screw
	t = str2double(get(hObject, 'Str'));
	if (isnan(t) || t <= 0),		set(hObject, 'Str', '0'),	end

% ---------------------------------------------------------------------------------------------
function push_opt_N_help_CB(hObject, handles)
	message = sprintf(['Limits the beams to which flagging will be applied.\n' ...
			'Only soundings for beams from min_beam to max_beam, inclusive, will have flags applied. ' ...
			'If the "REV" is checked then only beams outside the range will be flagged. ' ...
			'So for a Simrad EM1002 sounder with 111 beams 30 will only flag beam numbers 1 to 29 and 82 to 111.\n\n' ...
			'All good soundings, regardless of beam, will be included in the calculations of median, mean ' ...
			'and standard deviation for the bin.']);
	helpdlg(message,'Help on Limit beams');

% ---------------------------------------------------------------------------------------------
function push_OKareaclean_CB(hObject, handles)
% ...
	handles.opt_D_active = false;
	if (get(handles.check_opt_D, 'Val'))
		handles.opt_D_active = true;
		handles.opt_D_threshold = str2double(get(handles.edit_opt_D_threshold, 'Str'));
		handles.opt_D_nmin = str2double(get(handles.edit_opt_D_min, 'Str'));
	end

	handles.opt_M_active = false;
	if (get(handles.check_opt_M, 'Val'))
		handles.opt_M_active = true;
		handles.opt_M_threshold = str2double(get(handles.edit_opt_M_threshold, 'Str'));
		handles.opt_M_nmin = str2double(get(handles.edit_opt_M_min, 'Str'));
	end

	handles.opt_N_active = false;
	if (get(handles.check_opt_N, 'Val'))
		handles.opt_N_active = true;
		handles.opt_N_min = str2double(get(handles.edit_opt_N_min, 'Str'));
		handles.opt_N_Rev = false;
		if (get(handles.check_opt_N_Rev, 'Val'))
			handles.opt_N_Rev = true;
		end
	end
	
	handles.opt_G_active = (get(handles.check_opt_G, 'Val') ~= 0);

	x_min = get(handles.edit_x_min,'Str');		x_max = get(handles.edit_x_max,'Str');
	y_min = get(handles.edit_y_min,'Str');		y_max = get(handles.edit_y_max,'Str');
	if isempty(x_min) || isempty(x_max) || isempty(y_min) || isempty(y_max)
        errordlg('One or more grid limits are empty. Try with your yes open.','Error');    return
	end

	handles.opt_R = sprintf('-R%s/%s/%s/%s',x_min, x_max, y_min, y_max);
	x_inc = str2double(get(handles.edit_x_inc,'Str'));		y_inc = str2double(get(handles.edit_y_inc,'Str'));
	if (isnan(x_inc) || isnan(y_inc))
		errordlg('Grid increments are NaN. If you tried the dd:mm format that is not yet implemented.', 'Error')
		handles.opt_S = NaN;		% Must test this value on the calling fig
	else
		handles.opt_S = (x_inc + y_inc) / 2;
	end

	handles.areaclean = true;
	guidata(handles.figure1, handles)

	uiresume(handles.figure1);

% -------------------------------------------------------------------------------
function figure1_KeyPressFcn(hObject, eventdata)
	if isequal(get(hObject,'CurrentKey'),'escape')      % Check for "escape"
        uiresume(hObject);
	end

% --- Creates and returns a handle to the GUI figure. 
function h1 = mb_cleaning_params_LayoutFcn(h1)

	set(h1, 'Position',[520 306 401 381],...
	'Color',get(0,'factoryUicontrolBackgroundColor'),...
	'KeyPressFcn',@figure1_KeyPressFcn,...
	'NumberTitle','off',...
	'MenuBar','none',...
	'Name','MB cleaning params',...
	'NumberTitle','off',...
	'RendererMode','manual',...
	'Resize','off',...
	'HandleVisibility','callback',...
	'Tag','figure1');
	
	uicontrol('Parent',h1,'Position',[10 10 381 281],'Style','frame','Tag','frame2');
	uicontrol('Parent',h1,'Position',[21 123 173 60],'Style','frame','Tag','frame6');
	uicontrol('Parent',h1,'Position',[10 306 381 61],'Style','frame','Tag','frame1');
	
	uicontrol('Parent',h1,'Position',[21 313 55 21],...
	'BackgroundColor',[1 1 1],...
	'Callback',@mb_clean_par_uiCB,...
	'String','1%',...
	'Style','edit',...
	'TooltipString','Points further way from surface by this percentage of water depth are flagged',...
	'Tag','edit_percentDistGrid');
	
	uicontrol('Parent',h1,'Position',[88 313 61 21],...
	'BackgroundColor',[1 1 1],...
	'Callback',@mb_clean_par_uiCB,...
	'String','3',...
	'Style','edit',...
	'TooltipString','Number of iterations to acheive the percentage tolerance (starts at 3 times the percentage)',...
	'Tag','edit_nIterGrid');
	
	uicontrol('Parent',h1,'Position',[20 337 55 16],...
	'String','Tolerance',...
	'Style','text',...
	'Tag','text1');
	
	uicontrol('Parent',h1,'Position',[84 337 67 16],...
	'String','N iterations',...
	'Style','text',...
	'Tag','text2');
	
	uicontrol('Parent',h1,'Position',[167 313 61 21],...
	'BackgroundColor',[1 1 1],...
	'Callback',@mb_clean_par_uiCB,...
	'String','',...
	'Style','edit',...
	'TooltipString','Grid increment for the internal grid. Tipically 3 times the average point spacing.',...
	'Tag','edit_incGrid');
	
	uicontrol('Parent',h1,'Position',[240 313 35 21],...
	'Callback',@mb_clean_par_uiCB,...
	'FontSize',10,...
	'FontWeight','bold',...
	'String','?',...
	'Tag','push_helpGrid');
	
	uicontrol('Parent',h1,'Position',[292 313 90 23],...
	'Callback',@mb_clean_par_uiCB,...
	'FontSize',10,...
	'FontWeight','bold',...
	'String','OK',...
	'Tag','push_OKgrid');
	
	uicontrol('Parent',h1,'Position',[161 337 70 16],...
	'HorizontalAlignment','right',...
	'String','Grid spacing',...
	'Style','text',...
	'Tag','text3');
	
	uicontrol('Parent',h1,'Position',[21 198 361 75],'Style','frame','Tag','frame3');
	
	uicontrol('Parent',h1,'Position',[41 265 81 15],...
	'String','Grid Geometry',...
	'Style','text',...
	'Tag','text_opt_R');
	
	uicontrol('Parent',h1, 'Position',[59 232 80 21],...
	'BackgroundColor',[1 1 1],...
	'Callback',@mb_clean_par_uiCB,...
	'HorizontalAlignment','left',...
	'String','',...
	'Style','edit',...
	'Tag','edit_x_min');
	
	uicontrol('Parent',h1,'Position',[145 232 80 21],...
	'BackgroundColor',[1 1 1],...
	'Callback',@mb_clean_par_uiCB,...
	'HorizontalAlignment','left',...
	'String','',...
	'Style','edit',...
	'Tag','edit_x_max');
	
	uicontrol('Parent',h1,'Position',[59 206 80 21],...
	'BackgroundColor',[1 1 1],...
	'Callback',@mb_clean_par_uiCB,...
	'HorizontalAlignment','left',...
	'String','',...
	'Style','edit',...
	'Tag','edit_y_min');
	
	uicontrol('Parent',h1,'Position',[145 206 80 21],...
	'BackgroundColor',[1 1 1],...
	'Callback',@mb_clean_par_uiCB,...
	'HorizontalAlignment','left',...
	'String','',...
	'Style','edit',...
	'Tag','edit_y_max');
	
	uicontrol('Parent',h1,'Position',[25 237 30 15],...
	'HorizontalAlignment','right',...
	'String','Long',...
	'Style','text',...
	'Tag','text5');
	
	uicontrol('Parent',h1,'Position',[30 211 25 15],...
	'HorizontalAlignment','right',...
	'String','Lat',...
	'Style','text',...
	'Tag','text6');
	
	uicontrol('Parent',h1, 'Position',[165 253 41 13],...
	'String','Max',...
	'Style','text',...
	'Tag','text7');
	
	uicontrol('Parent',h1,'Position',[81 253 41 13],...
	'String','Min',...
	'Style','text',...
	'Tag','text8');
	
	uicontrol('Parent',h1,'Position',[230 232 71 21],...
	'BackgroundColor',[1 1 1],...
	'Callback',@mb_clean_par_uiCB,...
	'HorizontalAlignment','left',...
	'String','',...
	'Style','edit',...
	'TooltipString','DX grid spacing',...
	'Tag','edit_x_inc');
	
	uicontrol('Parent',h1,'Position',[230 206 71 21],...
	'BackgroundColor',[1 1 1],...
	'Callback',@mb_clean_par_uiCB,...
	'HorizontalAlignment','left',...
	'String','',...
	'Style','edit',...
	'TooltipString','DY grid spacing',...
	'Tag','edit_y_inc');
	
	uicontrol('Parent',h1, 'Position',[306 232 45 21],...
	'BackgroundColor',[1 1 1],...
	'Callback',@mb_clean_par_uiCB,...
	'HorizontalAlignment','left',...
	'String','',...
	'Style','edit',...
	'TooltipString','Number of columns in the grid',...
	'Tag','edit_Ncols');
	
	uicontrol('Parent',h1, 'Position',[306 206 45 21],...
	'BackgroundColor',[1 1 1],...
	'Callback',@mb_clean_par_uiCB,...
	'HorizontalAlignment','left',...
	'String','',...
	'Style','edit',...
	'TooltipString','Number of columns in the grid',...
	'Tag','edit_Nrows');
	
	uicontrol('Parent',h1, 'Position',[247 254 41 13],...
	'String','Spacing',...
	'Style','text',...
	'Tag','text9');
	
	uicontrol('Parent',h1, 'Position',[304 254 51 13],...
	'String','# of lines',...
	'Style','text',...
	'Tag','text10');
	
	uicontrol('Parent',h1,'Position',[354 205 21 48],...
	'BackgroundColor',[0.831372559070587 0.815686285495758 0.7843137383461],...
	'Callback',@mb_clean_par_uiCB,...
	'FontWeight','bold',...
	'ForegroundColor',[0 0 1],...
	'String','?',...
	'Tag','push_Help_R_F_T');
	
	uicontrol('Parent',h1, 'Position',[35 132 40 21],...
	'BackgroundColor',[1 1 1],...
	'Callback',@mb_clean_par_uiCB,...
	'String','2',...
	'Style','edit',...
	'TooltipString','Soundings that differ from the mean depth by a value greater than threshold times the standard deviation will be considered "bad"',...
	'Tag','edit_opt_D_threshold');
	
	uicontrol('Parent',h1, 'Position',[84 132 35 21],...
	'BackgroundColor',[1 1 1],...
	'Callback',@mb_clean_par_uiCB,...
	'String','10',...
	'Style','edit',...
	'TooltipString','Minimum number of soundings required to use the standard deviation filter',...
	'Tag','edit_opt_D_min');
	
	uicontrol('Parent',h1, 'Position',[80 175 61 15],...
	'String','STD filter',...
	'Style','text',...
	'Tag','text_STD');
	
	uicontrol('Parent',h1, 'Position',[28 155 55 15],...
	'String','Threshold',...
	'Style','text',...
	'Tag','text26');
	
	uicontrol('Parent',h1, 'Position',[85 155 35 15],...
	'String','nmin',...
	'Style','text',...
	'Tag','text27');
	
	uicontrol('Parent',h1, 'Position',[208 123 173 60],'Style','frame','Tag','frame7');
	
	uicontrol('Parent',h1, 'Position',[126 135 60 15],...
	'String','Use me',...
	'Style','checkbox',...
	'TooltipString','Use this option while filtering',...
	'Tag','check_opt_D');
	
	uicontrol('Parent',h1, 'Position',[161 156 25 21],...
	'Callback',@mb_clean_par_uiCB,...
	'FontSize',10,...
	'FontWeight','bold',...
	'String','?',...
	'Tag','push_opt_D_help');
	
	uicontrol('Parent',h1, 'Position',[222 132 40 21],...
	'BackgroundColor',[1 1 1],...
	'Callback',@mb_clean_par_uiCB,...
	'String','0.03',...
	'Style','edit',...
	'TooltipString','Soundings that differ from the median depth by a value greater than threshold times the sonar altitude will be considered "bad".',...
	'Tag','edit_opt_M_threshold');
	
	uicontrol('Parent',h1, 'Position',[272 132 35 21],...
	'BackgroundColor',[1 1 1],...
	'Callback',@mb_clean_par_uiCB,...
	'String','10',...
	'Style','edit',...
	'TooltipString','sets the minimum number of',...
	'Tag','edit_opt_M_min');
	
	uicontrol('Parent',h1, 'Position',[257 175 71 15],...
	'String','Median filter',...
	'Style','text',...
	'Tag','text_median');
	
	uicontrol('Parent',h1, 'Position',[215 155 55 15],...
	'String','Threshold',...
	'Style','text',...
	'Tag','text29');
	
	uicontrol('Parent',h1, 'Position',[273 155 35 15],...
	'String','nmin',...
	'Style','text',...
	'Tag','text30');
	
	uicontrol('Parent',h1, 'Position',[315 135 60 15],...
	'String','Use me',...
	'Style','checkbox',...
	'TooltipString','Use this option while filtering',...
	'Value',1,...
	'Tag','check_opt_M');
	
	uicontrol('Parent',h1, 'Position',[21 50 173 60], 'Style','frame','Tag','frame8');
	
	uicontrol('Parent',h1, 'Position',[350 156 25 21],...
	'Callback',@mb_clean_par_uiCB,...
	'FontSize',10,...
	'FontWeight','bold',...
	'String','?',...
	'Tag','push_opt_M_help');
	
	uicontrol('Parent',h1, 'Position',[35 59 40 21],...
	'BackgroundColor',[1 1 1],...
	'Callback',@mb_clean_par_uiCB,...
	'String','0',...
	'Style','edit',...
	'TooltipString','Only soundings for beams from min_beam to total beams - min_beam, inclusive, will have flags applied.',...
	'Tag','edit_opt_N_min');
	
	uicontrol('Parent',h1, 'Position',[80 102 71 15],...
	'String','Limit beams',...
	'Style','text',...
	'Tag','text_limits');
	
	uicontrol('Parent',h1, 'Position',[28 82 55 15],...
	'String','Min beam',...
	'Style','text',...
	'Tag','text32');
	
	uicontrol('Parent',h1, 'Position',[131 62 60 15],...
	'String','Use me',...
	'Style','checkbox',...
	'TooltipString','Use this option while filtering',...
	'Tag','check_opt_N');
	
	uicontrol('Parent',h1, 'Position',[78 62 40 15],...
	'String','Rev',...
	'Style','checkbox',...
	'TooltipString','Reverse the sense of this test. That is only beams OUTSIDE the min_beam/max_beam will be flagged',...
	'Tag','check_opt_N_Rev');
	
	uicontrol('Parent',h1, 'Position',[162 83 25 21],...
	'Callback',@mb_clean_par_uiCB,...
	'FontSize',10,...
	'FontWeight','bold',...
	'String','?',...
	'Tag','push_opt_N_help');
	
	uicontrol('Parent',h1, 'Position',[23 21 190 17],...
	'String','Set good any previously flagged',...
	'Style','checkbox',...
	'TooltipString','Unflag (set good) any previously flagged soundings that pass all of the specified statistical tests',...
	'Tag','check_opt_G');
	
	uicontrol('Parent',h1, 'Position',[292 20 90 23],...
	'Callback',@mb_clean_par_uiCB,...
	'FontSize',10,...
	'FontWeight','bold',...
	'String','OK',...
	'Tag','push_OKareaclean');
	
	uicontrol('Parent',h1, 'Position',[158 283 81 15],...
	'Enable','inactive',...
	'FontSize',9,...
	'String','Area Clean',...
	'Style','text',...
	'Tag','text_areaclean');
	
	uicontrol('Parent',h1, 'Position',[158 359 81 15],...
	'Enable','inactive',...
	'FontSize',9,...
	'String','Grid Clean',...
	'Style','text',...
	'Tag','text_gridclean');

% -----------------------------------------------------------------------------------
function mb_clean_par_uiCB(hObject, eventdata)
% This function is executed by the callback and than the handles is allways updated.
	feval([get(hObject,'Tag') '_CB'],hObject, guidata(hObject));
